import AsyncStorage from '@react-native-async-storage/async-storage';
import axios from 'axios';
import * as AuthSession from 'expo-auth-session';
// import * as Crypto from 'expo-crypto';

const SPOTIFY_CLIENT_ID = process.env.EXPO_PUBLIC_SPOTIFY_CLIENT_ID || '';

// Spotify API endpoints
const SPOTIFY_AUTH_URL = 'https://accounts.spotify.com/authorize';
const SPOTIFY_TOKEN_URL = 'https://accounts.spotify.com/api/token';
const SPOTIFY_API_BASE = 'https://api.spotify.com/v1';

// Storage keys
const ACCESS_TOKEN_KEY = 'spotify_access_token';
const REFRESH_TOKEN_KEY = 'spotify_refresh_token';
const TOKEN_EXPIRY_KEY = 'spotify_token_expiry';

export interface SpotifyUser {
  id: string;
  display_name: string;
  email: string;
  images: { url: string; height: number; width: number }[];
}

export interface SpotifyPlaylist {
  id: string;
  name: string;
  description: string;
  images: { url: string; height: number; width: number }[];
  tracks: {
    total: number;
  };
  owner: {
    id: string;
    display_name: string;
  };
}

export interface SpotifyTrack {
  id: string;
  name: string;
  artists: { name: string; id: string }[];
  album: {
    name: string;
    images: { url: string; height: number; width: number }[];
  };
  duration_ms: number;
  preview_url: string | null;
  uri: string;
}

export interface PlaylistTrack {
  track: SpotifyTrack;
  added_at: string;
}

class SpotifyService {
  private redirectUri: string;

  constructor() {
    // For development, use Expo's proxy. For production, use custom scheme
    this.redirectUri = AuthSession.makeRedirectUri({
      scheme: 'tunetoss',
      path: 'auth',
    });
  }

  // Authenticate with Spotify
  async authenticate(): Promise<boolean> {
    try {
      // Debug: Check if client ID is loaded
      console.log('Spotify Client ID:', SPOTIFY_CLIENT_ID ? 'Loaded' : 'Missing');
      console.log('Redirect URI:', this.redirectUri);
      
      if (!SPOTIFY_CLIENT_ID) {
        console.error('Spotify Client ID is missing. Check your .env.local file.');
        return false;
      }

      const request = new AuthSession.AuthRequest({
        clientId: SPOTIFY_CLIENT_ID,
        scopes: [
          'user-read-private',
          'user-read-email',
          'playlist-read-private',
          'playlist-read-collaborative',
          'playlist-modify-private',
          'playlist-modify-public',
        ],
        usePKCE: true,
        redirectUri: this.redirectUri,
        responseType: AuthSession.ResponseType.Code,
      });

      const result = await request.promptAsync({
        authorizationEndpoint: SPOTIFY_AUTH_URL,
      });

      if (result.type === 'success' && result.params.code) {
        // Use Expo to exchange the code; this automatically uses the request PKCE verifier
        const tokenResponse = await AuthSession.exchangeCodeAsync(
          {
            clientId: SPOTIFY_CLIENT_ID,
            redirectUri: this.redirectUri,
            code: result.params.code,
            extraParams: {
              // Use the internal verifier generated by AuthRequest
              code_verifier: (request as any).codeVerifier,
            },
          },
          { tokenEndpoint: SPOTIFY_TOKEN_URL }
        );
        
        if (tokenResponse) {
          await this.storeTokens(tokenResponse);
          return true;
        }
      }
      
      return false;
    } catch (error: unknown) {
      const err = error as { message?: string };
      console.error('Authentication error:', err?.message ?? String(error));
      return false;
    }
  }

  // Exchange authorization code for access token
  private async exchangeCodeForToken(code: string, codeVerifier: string) {
    try {
      // Create URL-encoded form data
      const params = new URLSearchParams();
      params.append('grant_type', 'authorization_code');
      params.append('code', code);
      params.append('redirect_uri', this.redirectUri);
      params.append('client_id', SPOTIFY_CLIENT_ID);
      params.append('code_verifier', codeVerifier);

      console.log('Token exchange params:', {
        grant_type: 'authorization_code',
        redirect_uri: this.redirectUri,
        client_id: SPOTIFY_CLIENT_ID ? 'Present' : 'Missing',
        code: code ? 'Present' : 'Missing',
        code_verifier: codeVerifier ? 'Present' : 'Missing',
      });

      const response = await axios.post(SPOTIFY_TOKEN_URL, params, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      });

      return response.data;
    } catch (error: any) {
      console.error('Token exchange error:', error);
      if (error.response) {
        console.error('Response status:', error.response.status);
        console.error('Response data:', error.response.data);
      }
      return null;
    }
  }

  // Store tokens securely
  private async storeTokens(tokenData: any) {
    // Support both axios/raw responses (snake_case) and AuthSession (camelCase)
    const accessToken = tokenData?.access_token ?? tokenData?.accessToken;
    const refreshToken = tokenData?.refresh_token ?? tokenData?.refreshToken ?? '';
    const expiresIn = tokenData?.expires_in ?? tokenData?.expiresIn ?? 3600;

    if (!accessToken) {
      throw new Error('Token response missing access token');
    }

    const expiryTime = Date.now() + expiresIn * 1000;

    await AsyncStorage.multiSet([
      [ACCESS_TOKEN_KEY, String(accessToken)],
      [REFRESH_TOKEN_KEY, String(refreshToken)],
      [TOKEN_EXPIRY_KEY, String(expiryTime)],
    ]);
  }

  // Get valid access token
  async getAccessToken(): Promise<string | null> {
    try {
      const [accessToken, expiryTime] = await AsyncStorage.multiGet([
        ACCESS_TOKEN_KEY,
        TOKEN_EXPIRY_KEY,
      ]);

      const token = accessToken[1];
      const expiry = parseInt(expiryTime[1] || '0');

      if (!token || Date.now() >= expiry) {
        // Token expired, try to refresh
        const refreshed = await this.refreshToken();
        if (refreshed) {
          return await AsyncStorage.getItem(ACCESS_TOKEN_KEY);
        }
        return null;
      }

      return token;
    } catch (error) {
      console.error('Error getting access token:', error);
      return null;
    }
  }

  // Refresh access token
  private async refreshToken(): Promise<boolean> {
    try {
      const refreshToken = await AsyncStorage.getItem(REFRESH_TOKEN_KEY);
      if (!refreshToken) return false;

      // Create URL-encoded form data
      const params = new URLSearchParams();
      params.append('grant_type', 'refresh_token');
      params.append('refresh_token', refreshToken);
      params.append('client_id', SPOTIFY_CLIENT_ID);

      const response = await axios.post(SPOTIFY_TOKEN_URL, params, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      });

      await this.storeTokens(response.data);
      return true;
    } catch (error) {
      console.error('Token refresh error:', error);
      return false;
    }
  }

  // Check if user is authenticated
  async isAuthenticated(): Promise<boolean> {
    const token = await this.getAccessToken();
    return !!token;
  }

  // Logout user
  async logout() {
    await AsyncStorage.multiRemove([
      ACCESS_TOKEN_KEY,
      REFRESH_TOKEN_KEY,
      TOKEN_EXPIRY_KEY,
    ]);
  }

  // Make authenticated API request
  private async apiRequest(endpoint: string, options: any = {}) {
    const token = await this.getAccessToken();
    if (!token) {
      throw new Error('No valid access token');
    }

    const response = await axios({
      url: `${SPOTIFY_API_BASE}${endpoint}`,
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      ...options,
    });

    return response.data;
  }

  // Get current user profile
  async getCurrentUser(): Promise<SpotifyUser | null> {
    try {
      return await this.apiRequest('/me');
    } catch (error) {
      console.error('Error fetching user profile:', error);
      return null;
    }
  }

  // Get user's playlists
  async getUserPlaylists(limit: number = 50, offset: number = 0): Promise<SpotifyPlaylist[]> {
    try {
      const response = await this.apiRequest(`/me/playlists?limit=${limit}&offset=${offset}`);
      return response.items || [];
    } catch (error) {
      console.error('Error fetching playlists:', error);
      return [];
    }
  }

  // Get playlist tracks
  async getPlaylistTracks(playlistId: string, limit: number = 50, offset: number = 0): Promise<PlaylistTrack[]> {
    try {
      const response = await this.apiRequest(`/playlists/${playlistId}/tracks?limit=${limit}&offset=${offset}`);
      return response.items || [];
    } catch (error) {
      console.error('Error fetching playlist tracks:', error);
      return [];
    }
  }

  // Get all playlist tracks (handles pagination)
  async getAllPlaylistTracks(playlistId: string): Promise<PlaylistTrack[]> {
    try {
      let allTracks: PlaylistTrack[] = [];
      let offset = 0;
      const limit = 50;
      let hasMore = true;

      while (hasMore) {
        const response = await this.apiRequest(`/playlists/${playlistId}/tracks?limit=${limit}&offset=${offset}`);
        const tracks = response.items || [];
        
        allTracks = [...allTracks, ...tracks];
        
        // Check if there are more tracks to fetch
        hasMore = tracks.length === limit && response.total > allTracks.length;
        offset += limit;
      }

      return allTracks;
    } catch (error) {
      console.error('Error fetching all playlist tracks:', error);
      return [];
    }
  }

  // Remove tracks from playlist
  async removeTracksFromPlaylist(playlistId: string, trackUris: string[]): Promise<boolean> {
    try {
      await this.apiRequest(`/playlists/${playlistId}/tracks`, {
        method: 'DELETE',
        data: {
          tracks: trackUris.map(uri => ({ uri })),
        },
      });
      return true;
    } catch (error) {
      console.error('Error removing tracks:', error);
      return false;
    }
  }
}

export const spotifyService = new SpotifyService();
